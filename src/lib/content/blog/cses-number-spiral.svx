---
title: "cses.fi - Number Spiral."
date: "2026-01-28"
type: "Competitive Programming"
status: "Completed"
description: "Solving the 'Number Spiral' problem on cses.fi."
tech: ["Rust", "Competitive Programming", "Data Structures", "Algorithms"]
---

<script>
import Note from "$lib/components/Note.svelte";
</script>

<hr/>

# Introduction

Welcome back! It's been a while... I went on a hiatus to spend some time working
on personal projects. However, I am ready to get back to finishing the cses.fi
problemset.

<br/>

Today we are going to be working on the following problem:
[Number Spiral](https://cses.fi/problemset/task/1071).

## The Problem

> A number spiral is an infinite grid whose upper-left square has number 1. Here
> are the first five layers of the spiral:

$$
\begin{array}{|c|c|c|c|c|}
\hline
1 & 2 & 9 & 10 & 25 \\
\hline
4 & 3 & 8 & 11 & 24 \\
\hline
5 & 6 & 7 & 12 & 23 \\
\hline
16 & 15 & 14 & 13 & 22 \\
\hline
17 & 18 & 19 & 20 & 21 \\
\hline
\end{array}
$$

> Your task is to find out the number in row $y$ and column $x$.

### Simplification

Up to this point, the code has been mostly repetitive. Let's try and
write some functions to make the parsing of our input far easier to
implement.

<br/>

What we want is something that can support reading a single item of
type $T$, and also reading a collection of white-space separated
things with type $T$. For example, for this problem our input looks
something like this:

<Note type="output">
3 <br/>
2 3 <br/>
1 1 <br/>
4 2 <br/>
</Note>

So then we would want to be able to write something like this:

```rust
fn main() {
   let t: u32 = read::<u32>();
   for _ in 0..t {
       let v: Vec<u32> = read_vec::<u32>();
       let y: u32 = v[0];
       let x: u32 = v[1];
   }
}
```

### Implementation

Now this can be implemented like so:

```rust
fn read<T>() -> T
where
    T: FromStr, <T as FromStr>::Err: std::fmt::Debug,
{
    let mut line = String::new();
    io::stdin().read_line(&mut line).expect("Failed to read a line");
    line.trim().parse::<T>().unwrap();
}

fn read_vec<T>() -> Vec<T>
where
    T: FromStr, <T as FromStr>::Err: std::fmt::Debug,
{
    let mut line = String::new();
    io::stdin().read_line(&mut line).expect("Failed to read a line");
    line
        .split_whitespace()
        .map(|s| s.trim().parse::<T>().unwrap())
        .collect()
}
```

<Note type="tip">
This may not be the best implementation, but for now it is a good start for
making our implementations more focused on the algorithm or data structures
being implemented rather than input parsing.
</Note>

## Problem Analysis

It's a good idea to first analyze this problem, this is definitely the first
problem we have encountered so far that is non-trivial at first glance.

Let's try and consider any patterns that we might find in the Number Spiral:

$$
\begin{array}{|c|c|c|c|c|}
\hline
\underline{1} & 2 & \underline{9} & 10 & \underline{25} \\
\hline
\underline{4} & 3 & 8 & 11 & 24 \\
\hline
5 & 6 & 7 & 12 & 23 \\
\hline
\underline{16} & 15 & 14 & 13 & 22 \\
\hline
17 & 18 & 19 & 20 & 21 \\
\hline
\end{array}
$$

The first thing to note is that as the $x$-coordinate moves from left to right,
if $y = 1$, then $(x, 1) = x^2$ when $x$ is odd. So we can see that the first
pattern reveals this:

$$
\begin{align}
(1, 1) &= 1^2 = 1 \\
(3, 1) &= 3^2 = 9 \\
(5, 1) &= 5^2 = 25
\end{align}
$$

Likewise with the $y$-coordinate as it moves from top to bottom, if $x = 1$,
then $(1, y) = y^2$ when $y$ is even. So we can see that this second pattern
reveals this:

$$
\begin{align}
(1, 2) &= 2^2 = 4 \\
(1, 4) &= 4^2 = 16
\end{align}
$$

But how is this helpful? Well, it turns out that this observation is
enough to construct the number at $(x, y)$! But how?

### Simplification

Let's break the problem down into two sub-problems: Either $x > y$, or $x \leq y$.
Now let's use this to analyse the problem further:

### If $x > y$
We now have two different situations to consider, either $x$ is even, or it is odd. If
$x$ is odd, we can take advantage of the observation above and derive this formula for
the number inside of the number spiral, given that $x > y$:

$$
(x, y) = x^2 - (y - 1)
$$

However, if $x$ is even, we can't necessarily take advantage of the observations above
directly. But we can combine the fact that $x > y$ and those observations to make new
ones. If $x$ is even, then we know that the value will fall on one of the following
lines passing through $x$:

$$
\begin{array}{|c|c|c|c|c|}
\hline
1 & \underline{2} & 9 & \underline{10} & 25 \\
\hline
4 & \underline{3} & 8 & \underline{11} & 24 \\
\hline
5 & \underline{6} & 7 & \underline{12} & 23 \\
\hline
16 & \underline{15} & 14 & \underline{13} & 22 \\
\hline
17 & \underline{18} & 19 & \underline{20} & 21 \\
\hline
\end{array}
$$

But we know that $x > y$, so this restricts it to the following possibilities:

$$
\begin{array}{|c|c|c|c|c|}
\hline
1 & \underline{2} & 9 & \underline{10} & 25 \\
\hline
4 & 3 & 8 & \underline{11} & 24 \\
\hline
5 & 6 & 7 & \underline{12} & 23 \\
\hline
16 & 15 & 14 & 13 & 22 \\
\hline
17 & 18 & 19 & 20 & 21 \\
\hline
\end{array}
$$

So how do we select the values on these lines for a given $x$ and $y$? We use
the fact that $x^2 - (x - 1)$ gives us the maximum value on the line defined
by a given value of $x$. Now to select the value based on the given $y$ value
we just subtract $x - y$. This gives us the final formula for this case:

$$
(x, y) = x^2 - (x - 1) - (x - y)
$$

So that gives us the formulae for calculating $(x, y)$ given that $x > y$.

### If $x \leq y$

Like when $x > y$, we take take advantage of those observations above and
derive the following equations for when $y$ is even:

$$
(x, y) = y^2 - (x - 1)
$$

and when $y$ is odd:

$$
(x, y) = y^2 - (y - 1) - (y - x)
$$

## Solution

Now that we have our formulae, we can implement it like so:

```rust
fn solve(x: u64, y: u64) -> u64 {
    if x > y {
        if x & 1 == 0 {
            return x*x - (x - 1) - (x - y);
        } else {
            return x*x - (y - 1);
        }
    } else {
        if y & 1 == 0 {
            return y*y - (x - 1);
        } else {
            return y*y - (y - 1) - (y - x);
        }
    }
}

fn main() {
   let t: u32 = read::<u32>();
   for _ in 0..t {
       let v: Vec<u64> = read_vec::<u64>();
       let y: u64 = v[0];
       let x: u64 = v[1];
       println!("{}", solve(x, y));
   }
}
```

And that's it! This is our final solution for [Number Spiral](https://cses.fi/problemset/task/1071).
