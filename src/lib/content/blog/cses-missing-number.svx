---
title: "cses.fi - Missing Number."
date: "2025-11-17"
type: "Competitive Programming"
status: "Completed"
description: "Solving the 'Missing Number' problem on cses.fi."
tech: ["Rust", "Competitive Programming", "Data Structures", "Algorithms"]
---

<hr/>

# Introduction

Welcome back to the series on the [cses.fi](https://cses.fi) problem set. A
series that goes through all of the problems on [cses.fi](https://cses.fi)!

<br/>

If you are new here, I am working my way through all of the problems in the
order they are presented on the site, so you can go back to see the solution to
the [weird algorthm](./cses-weird-algorithm) problem.

## The Problem

> You are given all numbers between $1, 2, ..., N$ except one. Your task is to find
> the missing number.

This is also relatively trivial to solve with something like a Set, but let's
try and be more creative with our solution. First, let's look at some examples
of inputs to see if we can come up with a solution from there:

```rust
fn solve(n: u32, v: Vec<u32>) {
    // ???
}

fn main() {
    solve(5, vec![1, 2, 3, 5]); // => 4
    solve(10, vec![1, 2, 3, 4, 6, 7, 8, 9, 10]); // => 5
    solve(7, vec![2, 3, 4, 5, 6, 7]); // => 1
}
```

We are quite lucky that we only have to find one number, because of this we can
take advantage of the following property to solve this problem:

$$
\text{solve}(n, v) = \frac{n (1 + n)}{2} - \sum_{i = 1}^{n - 1} v_{i - 1}
$$

But what does this equation mean? Let's break it down into it's concrete parts
first and talk about each part one at a time, the first part is this:

$$
\frac{n (1 + n)}{2}
$$

This is the equation, which is a function of $n$, which will tell you what
the sum of all of the numbers in $v = \{1, 2, ... n\}$ is. It's equivalent to the
following:

$$
\frac{n(1 + n)}{2} \equiv \sum_{1}^{n} v_{i - 1}
$$

Let's look at an example, for $v = \{1, 2, 3, 4, 5\}$

$$
1 + 2 + 3 + 4 + 5 = 15
$$

And with the equation we get:

$$
\frac{5(5 + 1)}{2} = \frac{5 \times 6}{2} = \frac{30}{2} = 15
$$

The same value! The trick of the equation is that there are $\frac{n}{2}$
instances of $n + 1$. So in the previous example, there are $2.5$ instances
of $6$, and this is true since we have $1, 2, 3, 4, 5$, but we can rewrite this
as:

$$
1 + 5, 2 + 4, 3 \equiv 6, 6, 3
$$

Which is exactly two and half copies of $6$.

<br/>

The next part is this:

$$
\sum_{i = 1}^{n - 1} v_{i - 1}
$$

This just describes the sum of all of the elements that we receive as part of
our input. So if had $v = \{1, 2, 3, 5\}$, then we have:

$$
\sum_{i = 1}^{n - 1} v_{i - 1} = 1 + 2 + 3 + 5 = 11
$$

Have you noticed how this solution works now? By subtracting the sum of our
input, from the sum of all the numbers from $1$ to $n$, we get the missing
number!

<br/>

With the example of $v = \{1, 2, 3, 5\}$, we get:

$$
\begin{aligned}
\text{solve}(5, \{1, 2, 3, 5\}) &= \frac{5(5 + 1)}{2} - (1 + 2 + 3 + 5) \\
&= 15 - 11 \\
&= 4
\end{aligned}
$$

And $4$ is exactly the missing element. Let's implement this:

```rust
use std::io;

fn main() {
    let mut input = String::new();
    io::stdin()
        .read_line(&mut input)
        .expect("Failed to read a line");
    let n: u64 = input
        .trim()
        .parse()
        .expect("The input was not a valid number");

    input.clear();

    io::stdin()
        .read_line(&mut input)
        .expect("Failed to read a line");

    let v: Vec<u64> = input
        .split(" ")
        .filter(|&s| s != " ")
        .map(|s| s.trim().parse().unwrap())
        .collect();

    let first_part: u64 = (1..n + 1).sum();
    let second_part: u64 = v.iter().sum();
    println!("{}", first_part - second_part);
}
```

This solution is probably rather convoluted and there are most likely libraries
that I can use to simplify the code a little bit with regards to the parsing
of the problem input, but I digress. This is the solution, and it passes all of
the test cases!

### Side Note

If you are solving a problem, it's important to consider the input constraints,
for this problem we see that the problem has the following input constraints:

$$
1 \leq n \leq 2 \times 10^{5}
$$

We preferably want to avoid the problem we faced when solving the first problem
[weird algorthm](./cses-weird-algorithm) where we used `u32` instead
of `u64`, which resulted in an overflow in our chosen type.

<br/>

We can be paranoid and choose to use `u64` for every problem that we do, but
this isn't always good since we will have memory constraints for some problems,
perhaps not for [cses.fi](https://cses.fi), but other platforms like codeforces
imposes these restrictions, and it is always good habit as we don't have unlimited memory.

<br/>

To determine whether using `u64` is necessary for our program, we can check to
see if the largest possible input will fit in a `u32` in the worst case. So
for $n = 2 \times 10^5$ we can check to see how many bits this consumes with
the following formula:

$$
\text{bits}(n) = \lceil {\text{log}(n, 2)} \rceil
$$

So $\text{bits}(2 \times 10^5) = 18 \; \text{bits}$ required to store this number.

<br/>

Great, so `u32` is good, right? No, we also perform a summation, and in the worst
case this will be from $1, 2, ..., 2 \times 10^5$. This summation is:

$$
\frac{(2 \times 10^{5})(1 + 2 \times 10^{5})}{2} = 20000100000
$$

Now this number requires $\text{bits}(20000100000) = 35 \; \text{bits}$. So, if we
were to use `u32`, we would have suffered the same fate.
